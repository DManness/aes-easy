import os
from cryptography.hazmat.primitives.ciphers import Cipher
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers.modes import CBC
from cryptography.hazmat.primitives.ciphers.algorithms import AES

class AESManager:
  """Provides ready to use functions for symetric encryption.
     This manager can handle functions of AES-CBC.
  """
  def __init__(self, key=None, key_length=32):
    """
      Parameters
      ----------
      key      : bytes
        (Optional) Sets the key (Default: generates a new key using the
        key_length parameter.)
      key_length : int
        (Optional) Overrides the length of the encryption key to generate.
        (Default: 32 bytes (256 bits))
    """
    super().__init__()
    self.backend = default_backend()
    self.key_length = key_length
    if key is None:
      key = self.generate_key( self.key_length )
    self.key = key

  def generate_key(self, key_length = 32):
    """Generates a random string of bytes that can be used as a key for symetric encryption.

    The key is generated with the host system's /dev/urandom, which should be
    sufficient for most applications.

    Please take care when storing the key or transmitting it over the network.
    On a unix system, you should restrict read access on the key to the
    application / user who will be using it.

    Parameters
    ----------
      key_length  : int
        The length of the key to generate. (Default: 32 bytes)
        Allowed key-lengths are 128, 192, 256, and 512.

    Returns
    -------
      bytes
        A string of bytes that can be used to encrypt a file.
    """
    return os.urandom(key_length)

  def encrypt(self, payload):
    """Encrypts a string of bytes

    Parameters
    ----------
    payload : bytes
      A string of bytes to be encrypted.

    Returns
    -------
    EncryptedFile :
      An object containing the encrypted data and the other parameters required
      to decode it.
    """
    if not isinstance(payload, bytes):
      raise TypeError("A bytes type object must be used for encryption")
    iv = os.urandom(16)
    cipher = Cipher( AES(self.key), CBC(iv), backend=self.backend)
    encryptor = cipher.encryptor()

    padding = len(iv) - len(payload) % len(iv)
    payload += b"\0" * padding

    encrypted_bytes = encryptor.update(payload) + encryptor.finalize()
    return EncryptedFile(iv, encrypted_bytes, padding)

  def decrypt(self, enc_data=None, iv=None, padding=0, enc_file=None):
    """Decrypts an AES encrypted string of bytes.

      Parameters
      ----------
      enc_data    : bytes
        Array of encrypted data. The entirety of the data is loaded into memory.
      iv      : bytes
        The initialization vector originally used to encrypt the file.
      padding : int
        The amount of padding that was required for CBC when encrypting the data
        (required for proper decryption)
      enc_file  : EncryptedFile
        As an alternative to providing the three parameters, you may also pass
        and instance of EncryptedFile. The class attributes will be extracted
        and used to decrypt the file.

      Returns
      -------
      bytes
        A decrypted string of bytes.
    """
    if (enc_file is not None and isinstance(enc_file, EncryptedFile) ):
      enc_data = enc_file.data
      iv = enc_file.iv
      padding = enc_file.padding
    elif (None in [enc_data, iv, padding]):
      raise ValueError("You must provide either enc_file or enc_data with iv.")

    if not isinstance(enc_data, bytes):
      raise TypeError("A bytes type object must be used for decryption")
    cipher = Cipher( AES(self.key), CBC(iv), backend=self.backend)
    decryptor = cipher.decryptor()
    decrypted_bytes = decryptor.update(enc_data) + decryptor.finalize()
    return decrypted_bytes[:-padding]

class EncryptedFile():
  """SecureSerialize File Format helper class.
  Represents an AES CBC file generated by AES Easy library.
  This class features convenience methods for reading and writing
  Secure_Serialize_AES format files.
  """

  """Constant used internally by the class when reading/writing from file"""
  ENDIANNESS = 'little'

  def __init__(self, iv=None, data=None, padding=None):
    """
      Parameters
      ----------
      iv      : bytes
        The initialization vector originally used to encrypt the file.
      data    : bytes
        Array of encrypted data. The entirety of the data is loaded into memory.
      padding : int
        The amount of padding that was required for CBC when encrypting the data
        (required for proper decryption)
    """

    super().__init__()
    self.iv = iv
    self.data = data
    self.padding = padding

  @staticmethod
  def read(path):
    """Load an encrypted SecureSerialize File Format file from a given path.

    Parameters
    ----------
    path  : str
      the fully qualified path to the encrypted SSFF file.

    Returns
    -------
    EncryptedFile
      A SecureSerialize file loaded into memory and ready to be decrypted.
    """
    with open(path, 'rb') as cfile:
      # Write the key_length to the file
      iv_len = int.from_bytes( cfile.read(2), byteorder=EncryptedFile.ENDIANNESS )
      padding = int.from_bytes( cfile.read(1), byteorder=EncryptedFile.ENDIANNESS )
      iv = cfile.read(iv_len)
      data = cfile.read()
    return EncryptedFile.__init__(iv, data, padding)
    pass

  def write(self, path):
    """Write this instance to a SecureSerialize File Format file.

    Parameters
    ----------
    path  : str
      the fully qualified path to store the encrypted SSFF file.
    """

    with open(path, 'wb') as cfile:
      self.iv, self.data
      cfile.write( len(self.iv).to_bytes(2, byteorder=EncryptedFile.ENDIANNESS) )
      cfile.write( self.padding.to_bytes(1, byteorder=EncryptedFile.ENDIANNESS) )
      cfile.write( self.iv )
      cfile.write( self.data )

  def __dict__(self):
    # Implemented to ensure compatibility with pickle object serialization.
    return {"iv": self.iv, "padding": self.padding, "data": self.data}